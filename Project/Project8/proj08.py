###############################################################################
#  CSE 231 Project #8
#
#  Algorithm
#  import copy module
#  declare constants with given value
#    define open_file(s) function that keeps repromting until a valid file name
#    is entered. It takes in a parameter s which specifies what type of file
#    to be inputted. It returns the file pointer. 
#
#    define read_names(fp) reads the Names.txt file using file pointer, fp and 
#    creates a names_lst with the names in the same order that they appear in  
#    file.
#
#    define read_friends(fp) takes the file pointer and the names_lst as
#    parameters and reads the Friends.csv file using file pointer, fp and 
#    creates a list of friends for each name whose index corresponds to the 
#    file line number (starting with 0). It returns a list of list of strings.
#
#    define create_friends_dict(names_lst,friends_lst) that takes lists
#    generated by the read_names(0 and read_friends() and creates a dictionary 
#    with key-value pair as name-list of friends. 
#
#    define find_common_friends(name1, name2, friends_dict) that takes two 
#    names and friends_dict, returns set of common friends for the two names
#
#    define find_max_friends(names_lst, friends_lst) that takes list of names 
#    and corresponding list of friends and finds the person with most friends. 
#
#    define find_max_common_friends(friends_dict) that takes friends dictionary
#    and finds which pairs of have the most friends in common. It returns a 
#    list of those pairs (each as a tuple) and number of friends they have.
#
#    define find_second_friends(friends_dict) that deals with second order 
#    friendships for each person in the network and finds the friends of their
#    friends, excluding personâ€™s first order friends or themselves in the form 
#    form of a dictionary with key as string and value as set.
#
#    define find_max_second_friends(seconds_dict) that finds maximum number of 
#    second-order friends, returns list of names and the maximum number of 
#    second-order friendships.
#  
#    define main() function
#       print the heading "\nFriend Network\n"
#       call open_file() with 'names' as parameter, assign it to filepointer fp
#       call read_names(fp) to generate names_lst
#       call open_file() with 'friends' as parameter, assign to filepointer fp
#       call read_friends(fp) to generate friends_lst
#       call create_friends_dict() with names_lst, friends_lst as parameters to 
#       create friends dictionary, friends_dict 
#       display the MENU of options
#       prompt user to input an option, check if option is valid, else print 
#       an error message and reprompt
#       main while loop
#           if opt equals 1
#              call find_max_friends(names_lst, friends_lst) to get 2 returned 
#              values: max_friends, max_val. Print max_val and loop through 
#              max_friends to display each person's name who has the max num of 
#              friends
#    
#           elif opt equals 2
#              call find_max_common_friends(friends_dict) to get two returned 
#              values: max_friends, max_val. Print max_val and loop through 
#              max_friends to display the pairs of non-friends with the most 
#              friends in common.
#    
#           elif opt equals 3
#              call find_second_friends(friends_dict) to create a seconds_dict 
#              of friends of friends. 
#              call find_max_second_friends(seconds_dict) to get two returned 
#              values: max_seconds, max_val. Print max_val and loop through 
#              max_seconds to display the people with the most second_order 
#              friends
#    
#           elif opt equals 4
#              prompt user to input a name
#              while loop
#                 if name inputted is in names_lst (valid name)
#                     if present, then loop through value of the key name in
#                     friends_dict to print all the friends' names for that
#                     person.  
#                     break while loop
#                 else if name is not in names_lst (invalid name)
#                     print error message, reprompt user for name input
#       
#           else
#              invalid opt entered from MENU. 
#           prompt user to input another option from MENU 
#           check again if option inputted is valid i.e. in '12345', else print 
#           an error message and reprompt 
#  call main() function
#  end of program
#
###############################################################################
import copy
MENU = '''
 Menu : 
    1: Popular people (with the most friends). 
    2: Non-friends with the most friends in common.
    3: People with the most second-order friends. 
    4: Input member name, to print the friends  
    5: Quit                       '''
    
def open_file(s):
    ''' This function prompts user to input file name to open and keeps 
    prompting until valid name is given.  s is a parameter, that tells
    the user what kind of file is being prompted for. s can be ("names",
    "friends"). 
    Parameters: string
    Returns: a file pointer
    Display: prompts and error messages '''
    
    while True:
        try:
            file_name = input("\nInput a {} file: ".format(s))
            fp = open(file_name,"r")
            break
        except FileNotFoundError: 
            #if invalide filename inputted, exception is raised
            print("\nError in opening file.") 
            continue
    return fp   #returning file pointer 


def read_names(fp):
    '''This function reads the Names.txt file using file pointer, fp and 
    creates a list with the names in the same order that they appear in the 
    file.'''
    name_list = []
    for line in fp: #iterating through each line of the file
        line = line.strip()  #splitting by ' '
        name_list.append(line)  #adding the names in file to names_list
    return name_list


def read_friends(fp,names_lst):
    '''This function reads the Friends.csv file using file pointer, fp and 
    creates a list of friends for each name whose index corresponds to the 
    file line number (starting with 0). 
    Parameter: file pointer, list of strings
    Returns: list of lists of strings
    Displays: nothing '''
    
    list_of_friend_lst = [] 
    for line in fp:  #iterating through each line of the file
        friend_list = []
        line = line.split(',') #splitting by ',' as it is a csv file
        
        for index in line:
            try:
                #trying to convert the list of indices in the file from string 
                #to int to use for indexing
                friend_name = names_lst[int(index)]
                friend_list.append(friend_name) #adding corresponding friend 
                                                #names to friend_list
            except ValueError:
                #if unable to convert to int, skip that index
                continue
        list_of_friend_lst.append(friend_list) #adding all friend_list to main
                                               #list_of_friend_lst which is 
                                               #returned by function
        
    return list_of_friend_lst
             


def create_friends_dict(names_lst,friends_lst):
    '''This function takes the two lists created in the read_names function and
    the read_friends function and builds a dictionary with name as the key and
    a list of friends as the value. 
    Parameter: list of strings, list of lists of strings
    Returns: dictionary (key is a string; value is a list of strings)
    Displays: nothing '''
    d = dict(zip(names_lst, friends_lst))  #creating a dict using zip operator
                                           #by using 2 lists
    return d
    
            
def find_common_friends(name1, name2, friends_dict):
    '''This function takes two names (strings) and the friends_dict (returned 
    by the create_friends_dict) and returns a set of friends that the two names
    have in common. 
    Parameter: string, string, dictionary
    Returns: set of strings
    Displays: nothing '''
    fset1 = set(friends_dict[name1]) #creates a set of friends of name1
    fset2 = set(friends_dict[name2])  #creates a set of friends of name2
    common_friends_set = fset1.intersection(fset2)  #finding the common friends
    return common_friends_set
    

def find_max_friends(names_lst, friends_lst):
    '''This function takes a list of names and the corresponding list of 
    friends and determines who has the most friends. 
    Parameter: list of strings, list of list of strings
    Returns: list of strings, int
    Displays: nothing '''
    
    #creating tuple with the length of list of friend names for each person
    num_friends_tup = tuple(len(friend) for friend in friends_lst) 
    
    #finding the max number of friends 
    max_num_friends = max(num_friends_tup)
    
    #finding the names of people who have the max number of friends
    max_friend_names = sorted([names_lst[i] for i, num in\
                               enumerate(num_friends_tup) if num ==\
                                   max_num_friends])
        
    return max_friend_names, max_num_friends
    
    
def find_max_common_friends(friends_dict):
    '''This function takes the friends dictionary and finds which pairs of 
    people have the most friends in common.  It returns a list of those pairs 
    with the most common friends and how many friends they have.  Each pair is
    represented as a tuple of names (strings).  Sort the list of tuples 
    alphabetically (makes testing consistent). 
    Parameter: dictionary 
    Returns: list of tuples of strings, int 
    Displays: nothing '''
    #create a deepcopy of friends_dict that is converted to list of tuples
    friends_dict1 = list(copy.deepcopy(friends_dict)) 
    
    list_of_pairs = []
    num_friends_tup = tuple()
    for i in range(len(friends_dict1)): #iterating through each index of list
        for j in range(i+1, len(friends_dict1)): 
            #here, we iterate through only those values of index that are 
            #greater than i from first loop (takes care of the 3 constraints),
            #then append the required pair to list_of_pairs.
            list_of_pairs.append((friends_dict1[i], friends_dict1[j]))
            
            #calling find_common_friends() to get set of common friends for
            #the 2 people
            common_friends_set = find_common_friends(friends_dict1[i],\
                                                     friends_dict1[j],\
                                                         friends_dict)
                
            #creating tuple with the length of set of friend names for the pair
            num_friends_tup += (len(common_friends_set),)
                
    #finding the max number of common friends 
    max_num_common_friends = max(num_friends_tup)
    
    #finding the names of pairs who have the max number of common friends
    max_common_friend_names = sorted(list_of_pairs[i] for i, num in\
                                     enumerate(num_friends_tup) if num ==\
                                         max_num_common_friends)
    return max_common_friend_names, max_num_common_friends
            
    
    
def find_second_friends(friends_dict):
    '''This function considers second order friendships for each person in the 
    network and finds the friends of their friends. It doesnâ€™t include the 
    personâ€™s first order friends or themselves.
    Parameter: dictionary 
    Returns: dictionary with key a string and value as a set.
    Displays: nothing '''
    second_order_friends_dict = {}
    
    for name in friends_dict:  
        #for every person in friends_dict we create new set of 2nd order friend
        second_order_friends = set()
        
        for first_order_friend in friends_dict[name]:
            #looping through list of first order friends of that person to 
            #keep adding to set of 2nd order friends the names of friends of
            #friends
            friends_of_friends_set = set(friends_dict[first_order_friend])
            second_order_friends = second_order_friends.union\
                (friends_of_friends_set)
                
        #remove the names of the first order friends and the name of person
        second_order_friends = second_order_friends.difference\
            (set(friends_dict[name]))
        second_order_friends.discard(name)
            
        #adding name-set of 2nd order friends to dictionary
        second_order_friends_dict[name] = second_order_friends
    return second_order_friends_dict
    
    

def find_max_second_friends(seconds_dict):
    '''This function finds the max of second-order friends. It returns list of
    names (strings) and the int that is the maximum number of second-order 
    friendships.
    Parameter: dictionary 
    Returns: list of strings, int
    Displays: nothing '''

    num_sec_friends_tup = ()
    for name in seconds_dict: 
        #iterating through every name in seconds_dict to add to tuple the 
        #number of 2nd order friends each person has
        num_sec_friends_tup += (len(seconds_dict[name]),)
        
    #finding the max number of second order friends 
    max_num_sec_friends = max(num_sec_friends_tup)
    
    #finding the names of people who have the max number of 2nd order friends
    max_sec_friend_names = sorted([name for (name, sec_friend_set) in\
                                   seconds_dict.items() if len(sec_friend_set)\
                                       == max_num_sec_friends])
        
    return max_sec_friend_names, max_num_sec_friends
    
    

def main():
    print("\nFriend Network\n")
    fp = open_file("names") 
    names_lst = read_names(fp)  
    fp = open_file("friends")
    friends_lst = read_friends(fp,names_lst)
    friends_dict = create_friends_dict(names_lst,friends_lst)

    print(MENU)
    choice = input("\nChoose an option: ") #prompt user to input option
    while choice not in "12345":
        #if invalid option inputted, print error message and reprompt
        print("Error in choice. Try again.")
        choice = input("Choose an option: ")
        
    while choice != '5': #if opt is not 5; if it is 5 then loop doesn't execute

        if choice == "1":
            #this choice is used to find the people with max number of friends
            #and ouput the their names along with max number of friends
            max_friends, max_val = find_max_friends(names_lst, friends_lst)
            print("\nThe maximum number of friends:", max_val)
            print("People with most friends:")
            for name in max_friends:
                print(name)
                
        elif choice == "2":
            #this option is used to find the pairs of non-friends with max 
            #number of common friends and max number of common friends
            max_names, max_val = find_max_common_friends(friends_dict)
            print("\nThe maximum number of commmon friends:", max_val)
            print("Pairs of non-friends with the most friends in common:")
            for name in max_names:
                print(name)
                
        elif choice == "3":
            #this option is used to find people with max number of 2nd order 
            #friends and ouput the their names along with max number of 2nd 
            #order friends
            seconds_dict = find_second_friends(friends_dict)
            max_seconds, max_val = find_max_second_friends(seconds_dict)
            print("\nThe maximum number of second-order friends:", max_val)
            print("People with the most second_order friends:")
            for name in max_seconds:
                print(name)
                
        elif choice == "4":
            #this option is used to display the names of friends a person has
            name = input("\nEnter a name: ")
            while True:
                if name in names_lst: 
                    #check if it's a valid name, then iterate through all names 
                    #of friends for that person in list of friends_dict (value
                    #of dictionary) and print them one-by-one.
                    print("\nFriends of {}:".format(name))
                    for friend in friends_dict[name]:
                        print(friend)
                    break
                    
                else: 
                    # if not a valid name, print error message and reprompt for 
                    #name as input
                    print("\nThe name {} is not in the list.".format(name))
                    name = input("\nEnter a name: ")
                    continue
    
        else:  #invalid input for choice given
            print("Shouldn't get here.")
            
        #once done with first iteration, for the next process, asks for new
        #input for choice
        choice = input("\nChoose an option: ")
        while choice not in "12345":
            #if invalid option inputted, print error message and reprompt
            print("Error in choice. Try again.")
            choice = input("Choose an option: ")

if __name__ == "__main__":
    main()
